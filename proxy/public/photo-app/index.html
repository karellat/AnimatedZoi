<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>Animated Drawings</title>
    <link rel="stylesheet" href="../style.css">
    <script src="../alpine.js" defer></script>
<script>
const backend = "http://localhost";

function fileInputToPng(file) {
    // if the file is image/png, we could return it
    // but we want to resize it to 1000px
    if (false && file.type === 'image/png') {
        return file
    }
    const reader = new FileReader();
    reader.readAsDataURL(file);
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    return new Promise(resolve => {
        reader.onload = () => {
            img.src = reader.result;
            // resize to 1000px
            img.onload = () => {
                canvas.width = Math.min(1000, img.width, 1000 * img.width / img.height)
                canvas.height = Math.min(1000, img.height, 1000 * img.height / img.width)
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                // convert to png
                canvas.toBlob(blob => {
                    resolve(blob);
                }, 'image/png');
            }
        }
    });
}

function crop(file, bbox) {
    const [l, t, r, b] = bbox;
    const reader = new FileReader();
    reader.readAsDataURL(file);
    const canvas = document.querySelector('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    return new Promise(resolve => {
        reader.onload = () => {
            img.src = reader.result;
            img.onload = () => {
                canvas.width = r - l
                canvas.height = b - t
                const scale = Math.max(img.width / 1000, img.height / 1000, 1.0);
                ctx.drawImage(img, l * scale, t * scale, canvas.width * scale, canvas.height * scale, 0, 0, canvas.width, canvas.height);
                // convert to png
                canvas.toBlob(blob => {
                    resolve(blob);
                }, 'image/png');
            }
        }
    });
}

function poseToYaml(pose) {
    const mapping = {'torso': [1, 'hip'], 'neck': [0, 'torso'], 'right_shoulder': [6, 'torso'], 'right_elbow': [8, 'right_shoulder'], 'right_hand': [10, 'right_elbow'], 'left_shoulder': [5, 'torso'], 'left_elbow': [7, 'left_shoulder'], 'left_hand': [9, 'left_elbow'], 'right_hip': [12, 'root'], 'right_knee': [14, 'right_hip'], 'right_foot': [16, 'right_knee'], 'left_hip': [11, 'root'], 'left_knee': [13, 'left_hip'], 'left_foot': [15, 'left_knee']}
    const yaml = []
    const canvas = document.querySelector('canvas');
    yaml.push(`height: ${canvas.height}`)
    yaml.push(`width: ${canvas.width}`)
    yaml.push('skeleton:')
    const left_hip = pose[mapping['left_hip'][0]]
    const right_hip = pose[mapping['right_hip'][0]]
    const root = [(left_hip[0] + right_hip[0]) / 2, (left_hip[1] + right_hip[1]) / 2]
    for (const name of ['root', 'hip']) {
        yaml.push(`- loc:`)
        yaml.push(`  - ${root[0]}`)
        yaml.push(`  - ${root[1]}`)
        yaml.push(`  name: ${name}`)
        yaml.push(`  parent: ${name == 'root' ? 'null' : 'root'}`)
    }
    for (const [name, [id, parent]] of Object.entries(mapping)) {
        const [x, y, score] = pose[id]
        yaml.push(`- loc:`)
        yaml.push(`  - ${x}`)
        yaml.push(`  - ${y}`)
        yaml.push(`  name: ${name}`)
        yaml.push(`  parent: ${parent}`)
    }
    const string = yaml.join('\n')
    return new File([string], 'pose.yaml', { type: 'text/yaml' })
}

async function formFetch(path, data, isJson=true) {
    const formData = new FormData();
    for (const [key, value] of Object.entries(data)) {
        formData.append(key, value)
    }
    const response = await fetch(`${backend}/${path}`, {
        method: 'POST',
        body: formData
    });    
    return isJson ? (await response.json()) : response;
}

async function getAnnotation(file) {
    const photo = await fileInputToPng(file)
    const detections = await formFetch('predictions/drawn_humanoid_detector', { data: photo })
    detections.sort((a, b) => b.score - a.score)
    const figure = await crop(file, detections[0].bbox)
    const poseResults = await formFetch('predictions/drawn_humanoid_pose_estimator', { data: figure })
    if (poseResults.length != 1) {
        throw `Detected ${poseResults.length} skeletons, expected 1`
    }
    return { figure, pose: poseResults[0].keypoints }
}

async function getAnimation(image, pose) {
    const char_cfg = poseToYaml(pose)
    const motion_id = 0
    const response = await formFetch('render', { motion_id, char_cfg, image }, false)
    return await response.blob()
}

function offerDownload(blob) {
    const a = document.createElement('a');
    const img = document.querySelector('#preview');
    a.download = "animace.gif";
    a.href = URL.createObjectURL(blob);
    a.dataset.downloadurl = ['image/gif', a.download, a.href].join(':');
    a.style.display = "none";
    img.src = a.href;
    a.click();
    a.remove();    
}

// returns true if the polyfill was necessary (and an image was captured)
function polyfillCapture() {
    return true;
}

</script>
</head>
<body class="flex" x-data="{ file: null, pose: [], figure: null, animation: null }">
<div class="container">
    <h1>Animated Drawings</h1>
    <ol>
        <li>
            <label onclick="return polyfillCapture()" for="file-input" class="btn active" :class="{'visited': file != null}">
                Získat fotografii
            </label>
            <input type="file" accept="image/*" class="hidden" capture="environment" id="file-input" @change="file = $el.files[0]" x-init="file = $el.files[0]">
        </li>
        <li x-data="{running: false}">
            <a href="#" class="btn" @click="!running && !!file && (running = true, pose = [], {figure, pose} = await getAnnotation(file), running = false)" :class="{ 'visited': pose.length, 'inactive': running || !file }">
                Detekovat postavu
            </a>
            <img x-show="running" src="../loading.gif" alt="loading" class="aside">
        </li>
        <li x-data="{running: false}">
            <a href="#" class="btn" @click="!running && !!file && (running = true, animation = await getAnimation(figure, pose), running=false, offerDownload(animation))" :class="{ 'inactive': running || !pose.length }">
                Animovat
            </a>
            <img x-show="running" src="../loading.gif" alt="loading" class="aside">
        </li>
    </ol>
</div>
<img x-show="animation != null" alt="animace" id="preview" @click="offerDownload(animation)">
<div class="relative" x-show="animation == null">
    <canvas id="canvas" width="1000" height="1000"></canvas>
    <div class="absolute" style="top: 0">
        <template x-for="point in pose">
            <div class="circle absolute" :style="`top: ${point[1]-5}px; left: ${point[0]-5}px;`">
        </template>
    </div>
</div>
<div class="footer">
    Meta Research & ZOI ÚTIA 2023
    <a href="/info">O projektu</a>
</div>
</body>
</html>