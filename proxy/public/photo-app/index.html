<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <title>Animated Drawings</title>
    <link rel="stylesheet" href="../style.css">
    <script src="../alpine.js" defer></script>
<script>
function fileInputToPng(file) {
    // if the file is image/png, we could return it
    // but we want to resize it to 1000px
    if (false && file.type === 'image/png') {
        return file
    }
    const reader = new FileReader();
    reader.readAsDataURL(file);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    return new Promise(resolve => {
        reader.onload = () => {
            img.src = reader.result;
            // resize to 1000px
            img.onload = () => {
                canvas.width = Math.min(1000, img.width, 1000 * img.width / img.height)
                canvas.height = Math.min(1000, img.height, 1000 * img.height / img.width)
                ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                // convert to png
                canvas.toBlob(blob => {
                    resolve(blob);
                }, 'image/png');
            }
        }
    });
}

function crop(file, bbox) {
    const [l, t, r, b] = bbox;
    const reader = new FileReader();
    reader.readAsDataURL(file);
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    const img = new Image();
    return new Promise(resolve => {
        reader.onload = () => {
            img.src = reader.result;
            img.onload = () => {
                canvas.width = r - l
                canvas.height = b - t
                ctx.drawImage(img, l, t, canvas.width, canvas.height, 0, 0, canvas.width, canvas.height);
                // convert to png
                canvas.toBlob(blob => {
                    resolve(blob);
                }, 'image/png');
            }
        }
    });
}

async function formFetch(model, file) {
    const formData = new FormData();
    formData.append("data", file)
    const response = await fetch(`http://localhost/predictions/${model}`, {
        method: 'POST',
        body: formData
    });
    return await response.json()
}

async function getAnimation(file) {
    const photo = await fileInputToPng(file)
    const detections = await formFetch('drawn_humanoid_detector', photo)
    detections.sort((a, b) => a.score - b.score)
    const figure = await crop(file, detections[0].bbox)
    const poseResults = await formFetch('drawn_humanoid_pose_estimator', figure)
    console.log(poseResults)
    if (poseResults.length != 1) {
        throw `Detected ${poseResults.length} skeletons, expected 1`
    }
}

// returns true if the polyfill was necessary (and an image was captured)
function polyfillCapture() {
    return true;
}

</script>
</head>
<body>
<div class="container flex justify-center" x-data="{ file: null, annotation: null}">
    <h1>Animated Drawings</h1>
    <ol>
        <li>
            <label onclick="return polyfillCapture()" for="file-input" class="btn active" :class="{'visited': file != null}">
                Získat fotografii
            </label>
            <input type="file" accept="image/*" class="hidden" capture="environment" id="file-input" @change="file = $el.files[0]" x-init="file = $el.files[0]">
        </li>
        <li x-data="{running: false}">
            <a href="#" class="btn" @click="!running && !!file && (running = true, annotation = await getAnimation(file), running = false)" :class="{ 'visited': annotation != null, 'inactive': running || !file }">
                Animovat
            </a>
            <img x-show="running" src="../loading.gif" alt="loading" class="aside">
        </li>
        <li>
            <a href="#" class="btn" x-data="{ active: true }" x-init="active = annotation != null" :class="{ 'inactive': !active }">
                Stáhnout
            </a>
        </li>
    </ol>
</div>
<div class="footer">
    Meta Research & ZOI ÚTIA 2023
    <a href="/info">O projektu</a>
</div>
</body>
</html>